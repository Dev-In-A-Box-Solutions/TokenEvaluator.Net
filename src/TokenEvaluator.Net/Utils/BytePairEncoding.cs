using System.Diagnostics;

namespace TokenEvaluator.Net.EncodingUtils;

internal class BytePairEncoding
{
    /// <summary>
    /// Performs a merge operation on byte pairs using a rank dictionary and a function to produce results.
    /// </summary>
    /// <typeparam name="T">The type of elements to be returned in the result list.</typeparam>
    /// <param name="piece">The byte array to merge.</param>
    /// <param name="ranks">The rank dictionary to use for merging.</param>
    /// <param name="f">The function to generate the result elements based on ranges of the byte array.</param>
    /// <returns>A list of elements of type T generated by the function parameter based on the merged byte array.</returns>
    static List<T> BytePairMerge<T>(byte[] piece, Dictionary<byte[], int> ranks, Func<Range, T> f)
    {
        var parts = Enumerable.Range(0, piece.Length + 1).Select(i => (i, int.MaxValue)).ToList();
        int? GetRank(int startIdx, int skip = 0)
        {
            if (startIdx + skip + 2 < parts.Count)
            {
                var slice = piece[parts[startIdx].i..parts[startIdx + skip + 2].i];
                if (ranks.TryGetValue(slice, out var rank))
                {
                    return rank;
                }
            }
            return null;
        }
        for (int i = 0; i < parts.Count - 2; i++)
        {
            var rank = GetRank(i);
            if (rank != null)
            {
                Debug.Assert(rank.Value != int.MaxValue);
                parts[i] = (parts[i].i, rank.Value);
            }
        }
        while (parts.Count > 1)
        {
            var minRank = (int.MaxValue, 0);
            for (int i = 0; i < parts.Count - 1; i++)
            {
                if (parts[i].MaxValue < minRank.MaxValue)
                {
                    minRank = (parts[i].MaxValue, i);
                }
            }
            if (minRank.MaxValue != int.MaxValue)
            {
                int i = minRank.Item2;
                parts[i] = (parts[i].i, GetRank(i, 1) ?? int.MaxValue);
                if (i > 0)
                {
                    parts[i - 1] = (parts[i - 1].i, GetRank(i - 1, 1) ?? int.MaxValue);
                }
                parts.RemoveAt(i + 1);
            }
            else
            {
                break;
            }
        }
        var outList = new List<T>(parts.Count - 1);
        for (int i = 0; i < parts.Count - 1; i++)
        {
            outList.Add(f(parts[i].i..parts[i + 1].i));
        }
        return outList;
    }

    /// <summary>
    /// Encodes a byte array using byte pair encoding, based on a rank dictionary.
    /// </summary>
    /// <param name="piece">The byte array to encode.</param>
    /// <param name="ranks">The rank dictionary to use for encoding.</param>
    /// <returns>A list of integers representing the ranks of the encoded byte pairs.</returns>
    public static List<int> BytePairEncode(byte[] piece, Dictionary<byte[], int> ranks)
    {
        if (piece.Length == 1)
        {
            return new List<int> { ranks[piece] };
        }
        return BytePairMerge(piece, ranks, p => ranks[piece[p.Start..p.End]]);
    }

    /// <summary>
    /// Splits a byte array into byte pairs, based on a rank dictionary.
    /// </summary>
    /// <param name="piece">The byte array to split.</param>
    /// <param name="ranks">The rank dictionary to use for splitting.</param>
    /// <returns>A list of byte arrays representing the split byte pairs.</returns>
    public static List<byte[]> BytePairSplit(byte[] piece, Dictionary<byte[], int> ranks)
    {
        if (piece.Length == 1)
        {
            return new List<byte[]> { piece };
        }
        return BytePairMerge(piece, ranks, p => piece[p.Start..p.End]);
    }
}