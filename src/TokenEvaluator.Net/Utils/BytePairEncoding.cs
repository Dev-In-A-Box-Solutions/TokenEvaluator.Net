using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace TokenEvaluator.Net.EncodingUtils
{
    /*
     * This class utilizes 'unsafe' methods in C#. 'Unsafe' in C# refers to a context
     * in which you can use pointers, perform type conversions that are normally disallowed,
     * as well as call native functions that are not part of the .NET framework.
     *
     * Points to note:
     * 1. Safety: Unsafe code has potential risks and can cause hard-to-detect bugs if not handled properly.
     *    It may lead to system instability or vulnerabilities if memory is manipulated incorrectly.
     *
     * 2. Speed: In some cases, unsafe code can provide more efficient memory manipulation and faster execution
     *    by reducing overhead. However, this comes at the cost of safety checks that the .NET runtime usually provides.
     *
     * 3. Interoperability: Unsafe code can be used to call native functions in DLLs and system APIs, allowing
     *    direct interaction with operating system services or third-party libraries that may not have .NET bindings.
     *
     * 4. Limitations: As unsafe code operates outside the bounds of the .NET runtime's type safety and memory
     *    safety checks, it should be used sparingly and only when necessary, as it can complicate debugging and maintenance.
     */

    internal static class BytePairEncoding
    {
        /// <summary>
        /// Performs a merge operation on byte pairs using a rank dictionary and a function to produce results.
        /// </summary>
        /// <typeparam name="T">The type of elements to be returned in the result list.</typeparam>
        /// <param name="piece">The byte array to merge.</param>
        /// <param name="ranks">The rank dictionary to use for merging.</param>
        /// <param name="f">The function to generate the result elements based on ranges of the byte array.</param>
        /// <returns>A list of elements of type T generated by the function parameter based on the merged byte array.</returns>
#if NETSTANDARD2_1_OR_GREATER || NET6_0_OR_GREATER
        internal static List<T> BytePairMerge<T>(byte[] piece, IReadOnlyDictionary<byte[], int> ranks, Func<Range, T> f)
#else
        internal static List<T> BytePairMerge<T>(byte[] piece, IReadOnlyDictionary<byte[], int> ranks, Func<Tuple<int, int>, T> f)
#endif
        {
            var parts = Enumerable.Range(0, piece.Length + 1).Select(i => (i, int.MaxValue)).ToList();
            int? GetRank(int startIdx, int skip = 0)
            {
                if (startIdx + skip + 2 < parts.Count)
                {
#if NETSTANDARD2_1_OR_GREATER || NET6_0_OR_GREATER
                     var slice = piece[parts[startIdx].i..parts[startIdx + skip + 2].i];
#else
                    var slice = piece.Skip(parts[startIdx].i).Take(parts[startIdx + skip + 2].i - parts[startIdx].i).ToArray();
#endif
                    if (ranks.TryGetValue(slice, out var rank))
                    {
                        return rank;
                    }
                }
                return null;
            }
            for (int i = 0; i < parts.Count - 2; i++)
            {
                var rank = GetRank(i);
                if (rank != null)
                {
                    Debug.Assert(rank.Value != int.MaxValue);
                    parts[i] = (parts[i].i, rank.Value);
                }
            }
            while (parts.Count > 1)
            {
                var minRank = (int.MaxValue, 0);
                for (int i = 0; i < parts.Count - 1; i++)
                {
                    if (parts[i].MaxValue < minRank.MaxValue)
                    {
                        minRank = (parts[i].MaxValue, i);
                    }
                }
                if (minRank.MaxValue != int.MaxValue)
                {
                    int i = minRank.Item2;
                    parts[i] = (parts[i].i, GetRank(i, 1) ?? int.MaxValue);
                    if (i > 0)
                    {
                        parts[i - 1] = (parts[i - 1].i, GetRank(i - 1, 1) ?? int.MaxValue);
                    }
                    parts.RemoveAt(i + 1);
                }
                else
                {
                    break;
                }
            }
            var outList = new List<T>(parts.Count - 1);
            for (int i = 0; i < parts.Count - 1; i++)
            {
#if NETSTANDARD2_1_OR_GREATER || NET6_0_OR_GREATER
                outList.Add(f(parts[i].i..parts[i + 1].i));
#else
                outList.Add(f(Tuple.Create(parts[i].i, parts[i + 1].i)));
#endif

            }
            return outList;
        }

        /// <summary>
        /// Encodes a byte array using byte pair encoding, based on a rank dictionary.
        /// </summary>
        /// <param name="piece">The byte array to encode.</param>
        /// <param name="ranks">The rank dictionary to use for encoding.</param>
        /// <returns>A list of integers representing the ranks of the encoded byte pairs.</returns>
        internal static List<int> BytePairEncode(byte[] piece, IReadOnlyDictionary<byte[], int> ranks)
        {
            if (piece.Length == 1)
            {
                return new List<int> { ranks[piece] };
            }
#if NETSTANDARD2_1_OR_GREATER || NET6_0_OR_GREATER
            return BytePairMerge(piece, ranks, p => ranks[piece[p.Start..p.End]]);
#else
            return BytePairMerge(piece, ranks, p => {
                byte[] key = piece.Skip(p.Item1).Take(p.Item2 - p.Item1).ToArray();
                return ranks.ContainsKey(key) ? ranks[key] : default;
            });
#endif
        }

        /// <summary>
        /// Splits a byte array into byte pairs, based on a rank dictionary.
        /// </summary>
        /// <param name="piece">The byte array to split.</param>
        /// <param name="ranks">The rank dictionary to use for splitting.</param>
        /// <returns>A list of byte arrays representing the split byte pairs.</returns>
        internal static List<byte[]> BytePairSplit(byte[] piece, IReadOnlyDictionary<byte[], int> ranks)
        {
            if (piece.Length == 1)
            {
                return new List<byte[]> { piece };
            }

#if NETSTANDARD2_1_OR_GREATER || NET6_0_OR_GREATER
            return BytePairMerge(piece, ranks, p => piece[p.Start..p.End]);
#else
            return BytePairMerge(piece, ranks, p => piece.Skip(p.Item1).Take(p.Item2 - p.Item1).ToArray());
#endif
        }

        // <summary>
        /// Extracts a sub-array from the specified byte array.
        /// </summary>
        /// <param name="bytes">The original byte array.</param>
        /// <param name="from">The starting index of the slice in the original array.</param>
        /// <param name="to">The ending index of the slice in the original array.</param>
        /// <returns>A new byte array representing the extracted slice.</returns>
        internal static byte[] GetSubArray(this byte[] bytes, int from, int to)
        {
#if NETSTANDARD2_1_OR_GREATER || NET6_0_OR_GREATER
            return bytes[from..to].ToArray();
#else
            return bytes.Skip(from).Take(to - from).ToArray();
#endif
        }

        /// <summary>
        /// Returns the length of a byte array.
        /// </summary>
        /// <param name="bytes">The byte array to get the length of.</param>
        /// <returns>The length of the byte array.</returns>
        internal static int GetLength(this byte[] bytes)
        {
#if NETSTANDARD2_1_OR_GREATER || NET6_0_OR_GREATER
            return bytes.Length;
#else
            return bytes.Count();
#endif
        }

        /// <summary>
        /// Finds the smallest rank and its index in a given rank array.
        /// </summary>
        /// <param name="partsRanks">The rank array.</param>
        /// <param name="count">The number of elements in the rank array.</param>
        /// <param name="result">The index of the smallest rank found.</param>
        /// <returns>A boolean indicating whether a minimum rank was found.</returns>
        internal static unsafe bool TryFindIndexOfMinRank(int* partsRanks, int count, out int result)
        {
            // This method searches for the smallest rank (minimum value) in the partsRanks array
            // and returns the index of that rank. The operation is quite efficient as it runs in 
            // linear time complexity O(n) - where n is the size of the array - which is the best possible 
            // time complexity for finding a minimum value in an unsorted array. This is because 
            // every element needs to be inspected at least once.
            //
            // If this method is called very frequently or on large data sets, alternative data 
            // structures such as a Min-Heap or a sorted array could be considered. These structures 
            // maintain order and could potentially offer constant time minimum value and index retrieval. 
            // However, such structures add complexity due to additional costs for insertion and maintenance. 
            // They would only be beneficial if minimum value/index retrieval is a frequent operation 
            // and the array changes infrequently.
            //
            // In conclusion, this method is already quite optimized for its purpose. Always remember 
            // the trade-off between optimizing the code and maintaining its readability and maintainability.
            result = 0;
            var minRank = int.MaxValue;
            for (var i = 0; i < count; i++)
            {
                if (partsRanks[i] < minRank)
                {
                    minRank = partsRanks[i];
                    result = i;
                }
            }
            return minRank != int.MaxValue;
        }

        /// <summary>
        /// Retrieves the rank of a byte slice from a rank dictionary.
        /// </summary>
        /// <param name="startIdx">The starting index of the slice in the original byte array.</param>
        /// <param name="partsIndexes">The index array.</param>
        /// <param name="count">The number of elements in the index array.</param>
        /// <param name="piece">The original byte array.</param>
        /// <param name="ranks">The rank dictionary.</param>
        /// <param name="length">The length of the slice.</param>
        /// <returns>The rank of the byte slice if found, else maximum integer value.</returns>
        internal static unsafe int GetRankOfSubArrayIfExists(int startIdx, int* partsIndexes, int count, byte[] piece, IReadOnlyDictionary<byte[], int> ranks, int length)
        {
            if (startIdx + length < count)
            {
                var from = partsIndexes[startIdx];
                var to = partsIndexes[startIdx + length];
                var slice = piece.GetSubArray(from, to);
                if (ranks.TryGetValue(slice, out var rank))
                {
                    return rank;
                }
            }
            return int.MaxValue;
        }

        /// <summary>
        /// Counts the number of encoded tokens in a given byte array using byte pair encoding.
        /// </summary>
        /// <param name="piece">The byte array to encode.</param>
        /// <param name="ranks">The rank dictionary for encoding.</param>
        /// <returns>The count of tokens in the encoded byte array.</returns>
        internal static unsafe int BytePairEncodeCountTokens(byte[] piece, IReadOnlyDictionary<byte[], int> ranks)
        {
            var partsLength = piece.Length + 1;
            var partsIndexes = stackalloc int[partsLength];
            var count = SplitByteArrayByRank(piece, partsIndexes, ranks);

            return count;
        }

        /// <summary>
        /// Finds the parts of a given byte array based on a rank dictionary.
        /// </summary>
        /// <param name="piece">The byte array to split into parts.</param>
        /// <param name="partsIndexes">The index array.</param>
        /// <param name="ranks">The rank dictionary for splitting.</param>
        /// <returns>The number of parts found in the byte array.</returns>
        internal static unsafe int SplitByteArrayByRank(byte[] piece, int* partsIndexes, IReadOnlyDictionary<byte[], int> ranks)
        {
            var partsLength = piece.Length + 1;
            var partsRanks = stackalloc int[partsLength];
            for (var i = 0; i < partsLength; i++)
            {
                partsIndexes[i] = i;
                partsRanks[i] = int.MaxValue;
            }
            for (var i = 0; i < partsLength - 2; i++)
            {
                partsRanks[i] = GetRankOfSubArrayIfExists(i, partsIndexes, partsLength, piece, ranks, length: 2);
            }

            var count = partsLength - 1;
            while (true)
            {
                if (!TryFindIndexOfMinRank(partsRanks, count, out var i))
                {
                    break;
                }

                partsRanks[i] = GetRankOfSubArrayIfExists(i, partsIndexes, count + 1, piece, ranks, length: 3);
                if (i > 0)
                {
                    partsRanks[i - 1] = GetRankOfSubArrayIfExists(i - 1, partsIndexes, count + 1, piece, ranks, length: 3);
                }
                for (var j = i + 1; j < count; j++)
                {
                    partsIndexes[j] = partsIndexes[j + 1];
                    partsRanks[j] = partsRanks[j + 1];
                }
                count--;
            }
            return count;
        }
    }
}